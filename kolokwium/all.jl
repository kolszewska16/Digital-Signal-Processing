# 2.06.2025
# filtr górnoprzepustowy, okno Hanninga
function rozwiazanie1(;
    order::Int = 48,
    fp::Float64 = 191.0,
    f0::Float64 = 66.85,
    z::Vector{Int} = [14, 33, 47],
)
    δ(n) = (n == 0) ? 1 : 0
    hanning(N) = [0.5 + 0.5 * cos((π * n) / (2 * N + 1)) for n in -N:N]

    n = -order / 2 : order / 2
    fg = f0 / fp
    h = zeros(Float64, length(n))

    for i in 1:length(n)
        h[i] = δ(n[i]) - 2 * sin(2 * π * fg * n[i]) / (2 * π * fg * n[i])
    end

    w = hanning(order / 2)
    hw = h .* w
    
    sum = 0
    for i in z
        sum += hw[i]
    end
    return sum
end

# 0.18286658126003053
rozwiazanie1()

# średnia dyskretnego sygnału
# fala piłokształtna o opadającym zboczu: A = 1, T = 1s, składowa stała: 0, g(0) = 0, dg/dt|t=0 = -2        
function rozwiazanie2(;
    fp::Float64 = 363.32,
    t1::Float64 = -6.95,
    N::Int = 76,
)
    g(t) = -2 * (t - floor(t + 0.5))
    x = range(start = t1, step = 1 / fp, length = N)
    y = [2.4 * g(2.4 * t - 2.7) for t in x]
    mean = sum(y) / length(y)
    return mean
end

# 0.6349655400198106
rozwiazanie2()

# średnia dyskretnego sygnału
# bipolarna fala prostokątna: A = 1, T = 1s, składowa stała: 0, g(0) = 1, g(t) = 0 dla 0 < t < 0.5      
function rozwiazanie3(;
    fp::Float64 = 371.56,
    t1::Float64 = 3.58,
    N::Int = 374,
)
    g(t) = sign(sin(2 * π * t))
    x = range(start = t1, step = 1 / fp, length = N)
    y = [3.6 * g(1.1 * t - 3.5) for t in x]
    mean = sum(y) / length(y)
    return mean
end

# 0.05775401069518711
rozwiazanie3()

# 3.06.2025
# średnia sygnału wyjściowego         
function rozwiazanie4(;
    x::Vector{Float64} = [-4.2, -4.49, -4.35, -2.19, -1.85, -2.99, 0.31, -1.75, 4.71, -2.75, -4.91, 0.09, 3.68, 3.28, -4.33, 2.79, 3.46, -3.34, 4.66, -1.41, 0.05, -0.37, -1.7, 4.39, -0.39, -3.74, -4.55, -1.81, -0.25, 2.29, 1.45, -2.97, 2.15, -2.55, -0.87, 3.58, 3.75, 2.53, -4.03, -3.78, 3.09, -3.2, 3.98, -3.69, 0.24, -0.55, -3.82, 2.35, 1.73, 4.02, -3.96, -4.14, 2.55, -0.73, 1.55, -0.49, 0.88, -0.65, 1.95, 4.88, 2.74, -1.43],
    h::Vector{Float64} = [-0.47, -1.2, 0.0, 4.28, 2.82, -2.73, -0.58, -4.44, -2.55, -1.91, 1.56, 0.98, -0.17, 0.15],
)
    function conv(x, h)
        N = length(x)
        M = length(h)
        K = N + M - 1
        y = zeros(Float64, K)

        for n in 1:K
            for m in 1:M
                if(n - m > 0 && n - m + 1 <= N)
                    y[n] += h[m] * x[n - m + 1]
                end
            end
        end
        return y
    end

    y = conv(x, h)
    mean = sum(y) / length(y)
    return mean 
end

# 0.6191199999999998
rozwiazanie4()

# średnie wzmocnienie 
function rozwiazanie5(;
    b::Vector{Float64} = [0.20589786767603166, -1.0861272640549327, 3.6226396155444696, -8.22906790017682, 14.482720679302624, -19.905487411076226, 22.227044074733804, -19.905487411076216, 14.482720679302618, -8.229067900176823, 3.622639615544471, -1.0861272640549329, 0.20589786767603174],
    a::Vector{Float64} = [1.0, -4.1018701585332575, 10.455001599833523, -18.605035749010852, 26.070359755268754, -29.249185399188946, 27.385569042192053, -21.411122854097236, 14.268286978394032, -7.919156210490829, 3.6616776168783667, -1.264252062931731, 0.2863185566670542],
    F::Vector{Float64} = [0.07, 0.09, 0.15, 0.2, 0.32],
)
    out = zeros(Float64, length(F))
    for i in 1:length(F)
        num = 0
        denom = 0
        for l in 1:length(b)
            num += b[l] * cispi(2 * F[i]) ^ -(l - 1)
        end
        for m in 1:length(a)
            denom += a[m] * cispi(2 * F[i]) ^ -(m - 1)
        end
        out[i] = abs(num / denom)
    end
    mean = sum(out) / length(out)
    return mean
end

# 0.5797457895466975
rozwiazanie5()

# 40-punktowe DFT
# suma amplitud składowych częstotliwościowych
function rozwiazanie6(;
    fp::Int = 840,
    x::Vector{ComplexF64} = ComplexF64[-1.42 - 1.3im, -0.86 + 0.71im, -0.61 + 0.32im, 0.74 - 0.46im, 0.13 - 0.22im, -0.46 - 1.2im, 0.85 + 0.14im, -0.3 - 0.4im, 1.4 + 1.36im, 0.74 - 0.19im, -0.23 - 2.32im, -0.65 + 1.46im, 0.03 + 0.88im, 0.06 - 0.24im, -0.05 - 0.96im, 0.18 - 0.67im, 0.77 - 0.16im, -0.04 + 0.5im, -0.55 + 1.21im, -0.53 + 0.44im, 0.57 + 0.59im, 0.02 + 0.32im, 0.08 + 1.05im, 0.42 + 0.72im, -0.46 - 1.27im, -0.22 - 0.5im, -0.32 - 0.49im, -0.19 + 0.22im, -0.12 + 0.67im, -1.19 - 1.4im, 0.29 - 0.39im, 0.57 + 0.65im, -0.64 - 0.25im, -0.46 - 0.97im, -0.86 - 0.39im, -0.25 - 0.27im, -0.37 - 1.16im, -0.09 + 0.59im, 0.4 + 1.06im, -0.51 + 0.53im],
    f::Vector{Int} = [-294, -273, -168, 0, 42, 273, 336],
)
    function dft(x)
        N = length(x)
        X = zeros(ComplexF64, N)
        for k in 1:N
            for n in 1:N
                X[k] += x[n] * cispi(-2 * (n - 1) * (k - 1) / N)
            end
        end
        return X / N
    end

    N = length(x)
    Δf = fp / N
    X = dft(x)
    F = zeros(Float64, N)
    F[Int(floor(N / 2) + 2)] = -(floor((N - 1) / 2)) * Δf
    out = 0

    for i in 1:(N - 1)
        if((i + 1) != floor(N / 2) + 2)
            F[i + 1] = F[i] + Δf
        end
    end

    for i in 1:N
        if(F[i] in f)
            out += abs(X[i])
        end
    end
    return out
end

# 1.001621818267306
rozwiazanie6()

# filtr dolnoprzepustowy, okno Hamminga     
function rozwiazanie7(;
    order::Int = 44,
    fp::Float64 = 190.0,
    f0::Float64 = 17.1,
    z::Vector{Int} = [20, 12, 6],
)
    hamming(N) = [0.54 + 0.46 * cos((2 * π * n) / (2 * N + 1)) for n in -N:N]
    n = -order / 2 : order / 2
    fg = f0 / fp
    h = zeros(Float64, length(n))

    for i in 1:length(n)
        h[i] = 2 * fg * sin(2 * π * fg * n[i]) / (2 * π * fg * n[i])
    end

    w = hamming(order / 2)
    hw = h .* w

    sum = 0
    for i in z
        sum += hw[i]
    end
    return sum
end

# 0.0993362886073199
rozwiazanie7()

# 4.06.2025
# średnie przesunięcie fazowe
function rozwiazanie8(;
    zz::Vector{ComplexF64} = ComplexF64[0.618237344495477 + 0.7859914667928534im, 0.618237344495477 - 0.7859914667928534im, 0.7880749527481846 + 0.6155792953397204im, 0.7880749527481846 - 0.6155792953397204im, 1.0 + 0.0im],
    pp::Vector{ComplexF64} = ComplexF64[0.4289087685769398 + 0.8645008129514766im, 0.4289087685769398 - 0.8645008129514766im, 0.1483245154470054 + 0.7829549048618939im, 0.1483245154470054 - 0.7829549048618939im, -0.3639175917140422 + 0.0im],
    k::Float64 = 0.14804660838937625,
    F::Vector{Float64} = [0.14, 0.17, 0.22],
)
    out = zeros(ComplexF64, length(F))
    for i in 1:length(F)
        num = 1
        denom = 1
        for z in 1:length(zz)
            num *= (1 - zz[z] * exp(-2im * π * F[i]))
        end
        for p in 1:length(pp)
            denom *= (1 - pp[p] * exp(-2im * π * F[i]))
        end
        out[i] += angle((k * num) / denom)
    end
    mean = sum(out) / length(out)
    return mean
end

# 0.2265263860426542
rozwiazanie8()

# wartość skuteczna       
function rozwiazanie9(;
    b::Vector{Float64} = [0.004262477289779243, -0.009198352988066403, 0.007421448096644399, 2.3661502145273754e-19, -0.0074214480966444, 0.009198352988066403, -0.004262477289779242],
    a::Vector{Float64} = [1.0, -3.717485611387743, 7.405375293261871, -8.885543194147186, 7.002666784025844, -3.323300419683556, 0.8455598080150633],
    x::Vector{Float64} = [-0.22, 0.27, -0.29, -0.09, -0.93, -0.5, 0.67, -0.24, 0.13, -0.22, 0.8, -0.88, 0.6, 0.84, 0.7, 0.14, 0.4, 0.43, -0.76, 0.14],
    L::Int = 47,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1) <= N)
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && (n - k + 1) <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end
    rms = sqrt(sum(abs.(y) .^ 2) / length(y))
    return rms
end

# 0.09298888276476627
rozwiazanie9()

# wartość skuteczna  
function rozwiazanie10(;
    b::Vector{Float64} = [0.17327242644714178, -0.8417443295265945, 1.8658198947340179, -2.3919295938041114, 1.8658198947340177, -0.8417443295265944, 0.17327242644714175],
    a::Vector{Float64} = [1.0, -1.9234073946110977, 2.3846685845801554, -1.7457173609326966, 0.836213821540958, -0.23354278972658468, 0.03005294382812647],
    x::Vector{Float64} = [-0.82, 0.05, -0.99, -0.94, 0.95, -0.05, -0.19, 0.54, 0.92, -0.18],
    L::Int = 33,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1) <= N)
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && n - k + 1 <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end

    rms = sqrt(sum(abs.(y) .^ 2) / L)
    return rms
end

# 0.3028891758471093
rozwiazanie10()

# średnie przesunięcie fazowe
function rozwiazanie11(;
    zz::Vector{ComplexF64} = ComplexF64[-1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im],
    pp::Vector{ComplexF64} = ComplexF64[0.4829321112470466 + 0.8373793951972854im, 0.4829321112470466 - 0.8373793951972854im, 0.6259309407570826 + 0.6473274226098389im, 0.6259309407570826 - 0.6473274226098389im, 0.8075750782653377 + 0.2579163503294173im, 0.8075750782653377 - 0.2579163503294173im],
    k::Float64 = 0.0006201142564604331,
    F::Vector{Float64} = [0.11, 0.23, 0.44, 0.46, 0.47],
)
    out = zeros(ComplexF64, length(F))
    for i in 1:length(F)
        num = 0
        denom = 0
        for z in 1:length(zz)
            num += (zz[z] * exp(-2im * π * F[i] * (z - 1)))
        end
        for p in 1:length(pp)
            denom += (pp[p] * exp(-2im * π * F[i] * (p - 1)))
        end
        out[i] += angle((k * num) / (1 + denom))
    end
    mean = sum(out) / length(out)
    return mean
end

# -1.8088212192685045
rozwiazanie11()

# średnia dyskretnego sygnału  
# fala trójkątna: A = 1, T = 1s składowa stała: 0, g(0) = 0, dg/dt|t=0 = 4
function rozwiazanie12(;
    fp::Float64 = 348.34,
    t1::Float64 = 7.9,
    N::Int = 178,
)
    g(t) = 4 * abs(t - floor(t + 3 / 4) + 1 / 4) - 1
    x = range(start = t1, step = 1 / fp, length = N)
    y = [3.5 * g(2.0 * t - 2.6) for t in x]

    mean = sum(y) / length(y)
    return mean
end

# 0.06267523722464141
rozwiazanie12()

# suma wartości
function rozwiazanie13(;
    m::Vector{Float64} = [1.5, 1.5013, 1.5026, 1.5039, 1.5052, 1.5065, 1.5078, 1.5091, 1.5104, 1.5117, 1.513, 1.5143, 1.5156, 1.5169, 1.5182, 1.5195, 1.5208, 1.5221, 1.5234, 1.5247, 1.526, 1.5273, 1.5286, 1.5299, 1.5312, 1.5325, 1.5338, 1.5351, 1.5364, 1.5377, 1.539, 1.5403, 1.5416, 1.5429, 1.5442, 1.5455, 1.5468, 1.5481, 1.5494, 1.5507, 1.552, 1.5533, 1.5546, 1.5559, 1.5572, 1.5585, 1.5598, 1.5611, 1.5624, 1.5637, 1.565, 1.5663, 1.5676, 1.5689, 1.5702, 1.5715, 1.5728, 1.5741, 1.5754, 1.5767, 1.578, 1.5793, 1.5806, 1.5819, 1.5832, 1.5845, 1.5858, 1.5871, 1.5884, 1.5897, 1.591, 1.5923, 1.5936, 1.5949, 1.5962, 1.5975, 1.5988, 1.6001, 1.6014, 1.6027, 1.604, 1.6053, 1.6066, 1.6079, 1.6092, 1.6105, 1.6118, 1.6131, 1.6144, 1.6157, 1.617, 1.6183, 1.6196, 1.6209, 1.6222],
    s::Vector{Float64} = [0.4453, 0.2384, 0.1678, 0.1146, 0.71, 0.8255, 0.5802, 0.127, 0.0629, 0.6115, 0.7163, 0.7815, 0.0352, 0.0009, 0.7175, 0.7398, 0.5994, 0.0879, 0.044, 0.441, 0.4491, 0.5701, 0.5553, 0.9446, 0.8127, 0.961, 0.8036, 0.7106, 0.9178, 0.8439, 0.5502, 0.8021, 0.6898, 0.2453, 0.8076, 0.929, 0.3281, 0.4846, 0.3781, 0.7229, 0.6809, 0.0386, 0.2428, 0.4211, 0.1225, 0.4613, 0.0937, 0.3703, 0.0686, 0.1241, 0.5614, 0.7369, 0.8523, 0.2, 0.2596, 0.0351, 0.7437, 0.1516, 0.9754, 0.7624, 0.6226, 0.7022, 0.0028, 0.052, 0.4161, 0.5086, 0.5203, 0.0388, 0.057, 0.9251, 0.2985, 0.6042, 0.1906, 0.7473, 0.8802, 0.0169, 0.7574, 0.8897, 0.4282, 0.9628, 0.8803, 0.543, 0.1947, 0.1676, 0.1536, 0.025, 0.6971, 0.0958, 0.0351, 0.858, 0.0551, 0.8112, 0.6127, 0.6489, 0.8762],
    t::Vector{Float64} = [1.61375, 1.50533, 1.50767, 1.58736, 1.61154, 1.58567, 1.61518, 1.52938, 1.55954, 1.61193, 1.50156, 1.56786, 1.50481, 1.50988],
)
    T = m[2] - m[1]
    y = zeros(Float64, length(t))

    for i in 1:length(t)
        for n in 1:length(s)
            y[i] += sinc((t[i] - m[n]) / T) * s[n]
        end
    end
    return sum(y)
end

# 5.870904229699802
rozwiazanie13()

# energia sygnału  
function rozwiazanie14(;
    b::Vector{Float64} = [0.005457396672935736, 0.021829586691742946, 0.032744380037614415, 0.021829586691742946, 0.005457396672935736],
    a::Vector{Float64} = [1.0, -2.6276616653091582, 3.169793721187013, -1.954960370796703, 0.5227556005796439],
    x::Vector{Float64} = [-0.78, -0.73, 0.47, -0.27, 0.58, 0.02, 0.41, 0.18, -0.24, -0.49, -0.05],
    L::Int = 50,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1) <= N)
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && (n - k + 1) <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end
    energy = sum(abs.(y) .^ 2)
    return energy
end

# 0.7464999967458876
rozwiazanie14()

# moc sygnału   
function rozwiazanie15(;
    b::Vector{Float64} = [0.0008063598650371028, 0.0, -0.003225439460148411, 0.0, 0.004838159190222617, 0.0, -0.003225439460148411, 0.0, 0.0008063598650371028],
    a::Vector{Float64} = [1.0, -4.015578080544881, 9.09469400165136, -13.299885407632388, 13.924302253227685, -10.381407931114726, 5.539287414559344, -1.905951341846375, 0.3708142159294545],
    x::Vector{Float64} = [-0.6, -0.76, 0.79, -0.13, -0.22, -0.82, -0.87, -0.34, -0.27, -0.62, -0.17, 0.19, 0.29, -0.4, 0.21, 0.57, 0.28, 0.21, 0.39, 0.09, 0.92, -0.66, -0.96, 0.52, 0.85, 0.84, -0.71, -0.8, 0.34, -0.39, -0.93, 0.97],
    L::Int = 62,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1) <= N)
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && (n - k + 1) <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end
    power = sum(abs.(y) .^ 2) / length(y)
    return power
end

# 0.030509866008322437
rozwiazanie15()

# wartość skuteczna sygnału
function rozwiazanie16(;
    b::Vector{Float64} = [0.018945298254741224, -0.017696236459281253, 0.034190475470654035, -0.01607593466612105, 0.03419047547065405, -0.01769623645928126, 0.01894529825474123],
    a::Vector{Float64} = [1.0, -3.272200970340843, 4.873632202004644, -4.057766231471863, 1.9796674599629442, -0.5296289800279481, 0.06109965973917386],
    x::Vector{Float64} = [-0.46, -0.99, 0.0, 0.42, 0.57, 0.96, 0.66, -0.15, -0.26, -0.3, 0.04, -0.93, 0.09, -0.39, 0.65, 0.04, -0.76, 0.3, -0.46, -0.37, -0.49, 0.82, -0.93, -0.21, 0.47, 0.07, -0.59, 0.54, 0.98, 0.87, -0.26, -0.32, -0.38, 0.66, 0.27, 0.25, 0.96, -0.48, -0.39, 0.25, -0.14, -0.52, -0.22],
    L::Int = 60,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1) <= N)
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && (n - k + 1) <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end
    rms = sqrt(sum(abs.(y) .^ 2) / length(y))
    return rms
end        

# 0.20785572155324977
rozwiazanie16()

# moc sygnału
function rozwiazanie17(;
    x::Vector{Float64} = [2.51, -1.74, -1.01, 0.19, 3.34, -4.55, -2.67, 1.4, 0.27, 4.7, 3.38, 2.0, -1.98, -4.61, 3.01, -4.43, 4.96, 1.78, -3.89, 3.08, 2.81, -4.62, 2.41, 2.1, -2.52, 0.35, -0.58, 4.48, -4.68, -1.55, 3.49, 2.67, -4.04, 4.7, 2.26, -4.94, 3.31, 3.53, -4.61, 1.78, 2.63, -2.82, 0.46, -3.21, -0.19, -1.44, -3.53, -4.93, -0.33, 0.21, 1.29, 4.86, 3.47, -2.15, -3.58, 4.98, 0.38, -2.4, 4.11, 2.07, 4.99, 3.97],
    h::Vector{Float64} = [0.79, -2.09, 0.79, 4.84, -0.13, 2.06, 0.91, -4.0, -2.18, 1.99, 2.44, 2.12],
)
    function conv(x, h)
        N = length(x)
        M = length(h)
        K = N + M - 1
        y = zeros(Float64, K)

        for n in 1:K
            for m in 1:M
                if((n - m) > 0 && (n - m + 1) <= N)
                    y[n] += h[m] * x[n - m + 1]
                end
            end
        end
        return y
    end

    y = conv(x, h)
    power = sum(abs.(y) .^ 2) / length(y)
    return power
end

# 740.1830334630137
rozwiazanie17()

# suma wartości sygnału g(t)          
function rozwiazanie18(;
    m::Vector{Float64} = [-2.4, -2.3979, -2.3958, -2.3937, -2.3916, -2.3895, -2.3874, -2.3853, -2.3832, -2.3811, -2.379, -2.3769, -2.3748, -2.3727, -2.3706, -2.3685, -2.3664, -2.3643, -2.3622, -2.3601, -2.358, -2.3559, -2.3538, -2.3517, -2.3496, -2.3475, -2.3454, -2.3433, -2.3412, -2.3391, -2.337, -2.3349, -2.3328, -2.3307, -2.3286, -2.3265, -2.3244, -2.3223, -2.3202, -2.3181, -2.316, -2.3139, -2.3118, -2.3097, -2.3076, -2.3055, -2.3034, -2.3013, -2.2992, -2.2971, -2.295, -2.2929, -2.2908, -2.2887, -2.2866, -2.2845, -2.2824, -2.2803, -2.2782, -2.2761, -2.274, -2.2719, -2.2698, -2.2677, -2.2656, -2.2635, -2.2614, -2.2593, -2.2572, -2.2551, -2.253, -2.2509],
    s::Vector{Float64} = [0.7452, 0.7087, 0.0138, 0.8951, 0.4073, 0.4276, 0.0448, 0.5468, 0.3452, 0.1164, 0.3736, 0.2974, 0.2617, 0.4393, 0.4261, 0.5137, 0.9904, 0.1674, 0.1667, 0.4039, 0.8123, 0.0702, 0.1954, 0.9833, 0.158, 0.7952, 0.8701, 0.3193, 0.7808, 0.689, 0.2071, 0.2962, 0.7494, 0.63, 0.8938, 0.8828, 0.393, 0.4709, 0.606, 0.5863, 0.5103, 0.7919, 0.2988, 0.4287, 0.386, 0.0663, 0.1574, 0.8301, 0.311, 0.6848, 0.1811, 0.5569, 0.281, 0.9884, 0.8383, 0.1676, 0.6669, 0.6685, 0.6016, 0.7637, 0.6428, 0.5916, 0.1587, 0.8124, 0.1038, 0.7768, 0.432, 0.5818, 0.8524, 0.3411, 0.9134, 0.9618],
    t::Vector{Float64} = [-2.31558, -2.38068, -2.34225, -2.27631, -2.2551, -2.39433, -2.32818, -2.37291, -2.27442, -2.27883],
)
    T = m[2] - m[1]
    out = zeros(Float64, length(t))

    for i in 1:length(t)
        for n in 1:length(s)
            out[i] += sinc((t[i] - m[n]) / T) * s[n]
        end
    end
    return sum(out)
end

# 5.712807518929044
rozwiazanie18()

# ???
# Oblicz odpowiedź impulsową h∈R15h∈R15 nierekursywnego filtru górnoprzepustowego rzędu 14 o liniowej charakterystyce fazowej. Filtr zaprojektuj tak aby przy częstotliwości próbkowania fp=193.0fp​=193.0 Hz, 3 dB pasmo przepustowe zaczynało się na częstotliwość f0=69.48f0​=69.48 Hz. Do zaprojektowania filtru wykorzystaj metodę okien czasowych i okno Blackmana. Jako rozwiązanie podaj sumę wartości wektora hh o indeksach z=[12,6,4,13,6,12]z=[12,6,4,13,6,12], to znaczy,
# ∑i=16hzi.
# i=1∑6​hzi​​.
# górnoprzepustowy, okno Blackmanna
function rozwiazanie19(;
    order::Int = 14,
    fp::Float64 = 193.0,
    f0::Float64 = 69.48,
    z::Vector{Int} = [12, 6, 4, 13, 6, 12],
)
    δ(n) = (n == 0) ? 1 : 0
    blackman(N) = [0.42 - 0.5 * cos((2 * π * n) / (2 * N - 1)) + 0.08 * cos((4 * π * n) / (2 * N - 1)) for n in -N:N]
    
    fg = f0 / fp
    n = -order / 2 : order / 2
    h = zeros(Float64, length(n))

    for i in 1:length(n)
        h[i] += δ(i) - 2 * fg * sin(2 * π * fg * n[i]) / (2 * π * fg * n[i])
    end

    w = blackman(order / 2)
    hw = h .* w
    
    sum = 0
    for i in z
        sum += hw[i]
    end
    return sum
end

# 0.03508581615202587
rozwiazanie19()

# moc sygnału          
function rozwiazanie20(;
    b::Vector{Float64} = [0.5714654181096676, -3.6548462159113435, 12.184770642960807, -26.492571511694212, 41.23527906042584, -47.585143698196894, 41.23527906042584, -26.49257151169421, 12.184770642960808, -3.6548462159113444, 0.5714654181096677],
    a::Vector{Float64} = [1.0, -5.734799907386861, 17.084159616729256, -33.13781114381352, 45.88765427844421, -46.9223637139893, 35.80658729852799, -20.07466514801493, 7.947460511819786, -2.010339240203334, 0.25716853747132096],
    x::Vector{Float64} = [-0.91, 0.43, 0.35, 0.3, -0.09, 0.12, -0.25, 0.79, -0.95, 0.29, 0.74, -0.54, 0.27, -0.94, -0.46, 0.81, 0.53, -0.24, -0.19, 0.04, 0.25, 0.13, -0.58, -0.15, -0.32, -0.27],
    L::Int = 54,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1) <= N)
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && (n - k + 1) <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end
    power = sum(abs.(y) .^ 2) / length(y)
    return power
end

# 0.09490245385535188
rozwiazanie20()

# 5.06.2025
# moc sygnału
function rozwiazanie21(;
    x::Vector{Float64} = [-4.82, -2.47, -0.28, -2.84, 2.68, 3.45, -4.19, 4.2, -1.07, -2.55, 3.56, 0.07, -1.9, -1.27, -1.25, 3.55, 0.4, 3.41, -4.67, 3.55, -3.43, -4.31, -1.09, 2.36, -4.15, 1.46, -0.69, -1.65, 3.44, 0.13, 1.09, -4.92, -2.29, 3.2, 2.41, 1.81, -0.88, -3.71, 4.75, 4.97, -3.94, 2.4, 0.51, -0.09, -4.73, -0.7, -2.34, -2.02, -0.72, -0.01, -3.79, -4.01, 4.74, -4.53, 1.35, 2.77, 3.65, -2.08, -4.1, -4.07, 2.28, 0.96, -2.05],
    h::Vector{Float64} = [-0.39, -1.52, 3.63, -0.23, -2.92, -4.16, 1.38, 4.01, -1.19, -1.04, -2.17, -4.27, -0.7, 2.32],
)
end

# 6.06.2025
# ???
# średnie wzmocnienie
function rozwiazanie22(;
    b::Vector{Float64} = [0.02323724580688303, 0.002184894745921451, 0.03735705202248415, 0.014510480674151501, 0.03735705202248415, 0.002184894745921463, 0.02323724580688304],
    a::Vector{Float64} = [1.0, -2.696281855877605, 3.5716499417610215, -2.6755482446481462, 1.2052677278669994, -0.2977269281411945, 0.0327082248636542],
    F::Vector{Float64} = [0.16, 0.23, 0.3, 0.3, 0.39, 0.39],
)
    out = zeros(Float64, length(F))

    for i in 1:length(F)
        num = 1
        denom = 1
        for n in 1:length(b)
            num *= (1 - b[n] * exp(-2im * π * F[i]))
        end
        for m in 1:length(a)
            denom *= (1 - a[m] * exp(-2im * π * F[i]))
        end
        out[i] += abs(num / denom)
    end
    mean = sum(out) / length(out)
    return mean
end

rozwiazanie22()

# suma wartości sygnału g(t)          
function rozwiazanie23(;
    m::Vector{Float64} = [5.0, 5.0018, 5.0036, 5.0054, 5.0072, 5.009, 5.0108, 5.0126, 5.0144, 5.0162, 5.018, 5.0198, 5.0216, 5.0234, 5.0252, 5.027, 5.0288, 5.0306, 5.0324, 5.0342, 5.036, 5.0378, 5.0396, 5.0414, 5.0432, 5.045, 5.0468, 5.0486, 5.0504, 5.0522, 5.054, 5.0558, 5.0576, 5.0594, 5.0612, 5.063, 5.0648, 5.0666, 5.0684, 5.0702, 5.072, 5.0738, 5.0756, 5.0774, 5.0792, 5.081, 5.0828, 5.0846, 5.0864, 5.0882, 5.09, 5.0918, 5.0936, 5.0954, 5.0972, 5.099],
    s::Vector{Float64} = [0.6167, 0.6029, 0.0767, 0.4801, 0.842, 0.9894, 0.4116, 0.7124, 0.7167, 0.6716, 0.4932, 0.1193, 0.4537, 0.3266, 0.0644, 0.9941, 0.8953, 0.9452, 0.2369, 0.1021, 0.975, 0.092, 0.851, 0.6142, 0.7159, 0.2125, 0.0939, 0.8417, 0.4644, 0.5025, 0.3378, 0.1023, 0.6303, 0.7369, 0.112, 0.6815, 0.1548, 0.0126, 0.465, 0.8415, 0.8109, 0.2993, 0.069, 0.0024, 0.9213, 0.1643, 0.1567, 0.378, 0.4733, 0.6144, 0.3837, 0.1336, 0.25, 0.8356, 0.5975, 0.0967],
    t::Vector{Float64} = [5.04896, 5.07704, 5.07002, 5.0018, 5.0873, 5.0621, 5.06084, 5.07884],
)
    T = m[2] - m[1]
    out = zeros(Float64, length(t))

    for i in 1:length(t)
        for n in 1:length(s)
            out[i] += sinc((t[i] - m[n]) / T) * s[n]
        end
    end
    return sum(out)
end

# 4.03736714218586
rozwiazanie23()

# 7.06.2025
#wartość skuteczna sygnału błędu kwantyzacji          
function rozwiazanie24(;
    a::Float64 = -2.4,
    b::Float64 = 4.9,
    x::Vector{Float64} = [-1.84, -1.3681, -0.89621, -0.42431, 0.04758, 0.51948, 0.99137, 1.46327, 1.93516, 2.40706, 2.87895, 3.35085, 3.82275, 4.29464, 4.76654, 4.76157, 4.28967, 3.81778, 3.34588, 2.87399, 2.40209, 1.9302, 1.4583, 0.98641, 0.51451, 0.04261, -0.42928, -0.90118, -1.37307, -1.84497, -2.31686, -2.41124, -1.93935, -1.46745, -0.99556, -0.52366, -0.05176, 0.42013, 0.89203, 1.36392, 1.83582, 2.30771, 2.77961, 3.2515, 3.7234, 4.19529, 4.66719, 4.86092, 4.38902, 3.91712, 3.44523, 2.97333],
)
    quantize(L) = x -> L[argmin(abs.(x .- L))]
    N = 5
    L = range(start = a, stop = b, length = 2 ^ N)

    q = quantize(L)
    x_q = q.(x)
    e = x - x_q
    rms = sqrt(sum(abs.(e) .^ 2) / length(e))
    return rms
end

# 0.07288866395547805
rozwiazanie24()

# energia sygnału          
function rozwiazanie25(;
    b::Vector{Float64} = [0.15220776723622292, -0.6306612471456423, 1.1561685097078895, -1.1561685097078895, 0.6306612471456425, -0.15220776723622292],
    a::Vector{Float64} = [1.0, -1.1397725742429585, 1.51371415095299, -0.3171939570028648, 0.16876931161974204, 0.2613749456390448],
    x::Vector{Float64} = [-0.12, -0.57, -0.18, -0.44, -0.71, -0.46, -0.38, 0.9, 0.43, 0.28, -0.41, 0.73, -0.7, -0.24, -0.63, -0.06, -0.85, 0.07, 0.76, -0.37, 0.99, 0.21, 0.26, -0.16, -0.01, -0.66, 0.48],
    L::Int = 54,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1 <= N))
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && (n - k + 1) <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end

    energy = sum(abs.(y) .^ 2)
    return energy
end

# 3.3525141321526473
rozwiazanie25()

# moc sygnału błędu kwantyzacji
function rozwiazanie26(;
    a::Float64 = 0.012,
    b::Float64 = 1.0,
    x::Vector{Float64} = [0.13305, 0.98145, 0.37559, 0.31889, 0.84739, 0.02241, 0.49414, 0.19375, 0.03932, 0.03012, 0.5985, 0.99967, 0.99355, 0.37716, 0.9379, 0.39295, 0.10757, 0.99736, 0.86859, 0.14917, 0.28943, 0.54582, 0.05613, 0.28957, 0.11021, 0.06435, 0.45682, 0.21672, 0.7949, 0.94166, 0.38783, 0.31799, 0.47476, 0.7604, 0.53043, 0.42237, 0.128, 0.82555, 0.97188, 0.67314, 0.68017, 0.16836, 0.54768, 0.98845, 0.50107, 0.04717, 0.16646, 0.60658, 0.97931, 0.38437, 0.6112, 0.92558, 0.06762, 0.15936, 0.47644, 0.17024, 0.60476, 0.46096, 0.72281, 0.01185],
)
    quantize(L) = x -> L[argmin(abs.(x .- L))]
    N = 9
    L = range(start = a, stop = b, length = 2 ^ N)

    q = quantize(L)
    x_q = q.(x)
    e = x - x_q
    power = sum(abs.(e) .^ 2) / length(e)
    return power
end

# 2.624699320685337e-7
rozwiazanie26()

# suma wartości sygnału g(t)
function rozwiazanie27(;
    m::Vector{Float64} = [-4.4, -4.3978, -4.3956, -4.3934, -4.3912, -4.389, -4.3868, -4.3846, -4.3824, -4.3802, -4.378, -4.3758, -4.3736, -4.3714, -4.3692, -4.367, -4.3648, -4.3626, -4.3604, -4.3582, -4.356, -4.3538, -4.3516, -4.3494, -4.3472, -4.345, -4.3428, -4.3406, -4.3384, -4.3362, -4.334, -4.3318, -4.3296, -4.3274, -4.3252, -4.323, -4.3208, -4.3186, -4.3164, -4.3142, -4.312, -4.3098, -4.3076, -4.3054, -4.3032, -4.301, -4.2988, -4.2966, -4.2944, -4.2922, -4.29, -4.2878, -4.2856, -4.2834, -4.2812, -4.279, -4.2768, -4.2746, -4.2724, -4.2702, -4.268, -4.2658, -4.2636, -4.2614, -4.2592, -4.257, -4.2548, -4.2526, -4.2504, -4.2482, -4.246, -4.2438, -4.2416, -4.2394, -4.2372, -4.235],
    s::Vector{Float64} = [0.2093, 0.135, 0.7553, 0.1361, 0.4894, 0.7307, 0.2421, 0.607, 0.3682, 0.9482, 0.2295, 0.1214, 0.7435, 0.4052, 0.6568, 0.24, 0.1059, 0.494, 0.609, 0.5229, 0.5399, 0.9013, 0.2669, 0.5727, 0.1893, 0.0981, 0.656, 0.5096, 0.0252, 0.2037, 0.9166, 0.8604, 0.5339, 0.1211, 0.7961, 0.7743, 0.2935, 0.9033, 0.0011, 0.6826, 0.6409, 0.2444, 0.506, 0.1096, 0.9047, 0.0165, 0.1976, 0.5125, 0.5327, 0.422, 0.419, 0.6306, 0.5461, 0.9031, 0.5712, 0.642, 0.7575, 0.4017, 0.3886, 0.0928, 0.0221, 0.146, 0.1314, 0.8075, 0.8344, 0.14, 0.5018, 0.3626, 0.5003, 0.5544, 0.662, 0.2722, 0.7656, 0.5729, 0.3939, 0.5898],
    t::Vector{Float64} = [-4.26404, -4.37602, -4.39076, -4.3758, -4.29374],
)
    T = m[2] - m[1]
    out = zeros(Float64, length(t))

    for i in 1:length(t)
        for n in 1:length(s)
            out[i] += sinc((t[i] - m[n]) / T) * s[n]
        end
    end
    return sum(out)
end

# 1.5178333152365893
rozwiazanie27()

# 8.06.2025
# stabilność          
function rozwiazanie28(;
    z::Vector{ComplexF64} = ComplexF64[-1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im],
    p::Vector{ComplexF64} = ComplexF64[0.43933548561598673 + 0.4905063056423592im, 3.335919704955171 - 3.724465024952148im, 0.3423765257286831 + 0.0im],
    k::Float64 = 0.045617789533833566,
)
    for pole in p
        if(abs(pole) > 1)
            return -1.0
        end
    end
    for pole in p
        if(abs(pole) <= 1)
            return 1.0
        end
    end
end

# -1.0
rozwiazanie28()

# ???
# średnie przesunięcie fazowe
function rozwiazanie29(;
    b::Vector{Float64} = [0.04314525874746985, -0.2588715524848191, 0.6471788812120477, -0.862905174949397, 0.6471788812120477, -0.2588715524848191, 0.04314525874746985],
    a::Vector{Float64} = [1.0, -0.38574424913684624, 1.3013655603245946, 0.13270353683808567, 0.5561248128464324, 0.17251600265356282, 0.160210615122618],
    F::Vector{Float64} = [0.15, 0.16, 0.24],
)
    out = zeros(ComplexF64, length(F))
    for i in 1:length(F)
        num = 0
        denom = 0
        for m in 1:length(b)
            num += (b[m] * exp(-2im * π * F[i]) ^ (m - 1))
        end
        for k in 2:length(a)
            denom += (a[k] * exp(-2im * π * F[i]) ^ (k - 1))
        end
        out[i] += angle(num / (1 + denom))
    end
    mean = sum(out) / length(out)
    return mean
end

# 0.4520467406199362
rozwiazanie29()

# stabilność
function rozwiazanie30(;
    z::Vector{ComplexF64} = ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im],
    p::Vector{ComplexF64} = ComplexF64[4.9999787849080635 - 0.01456538599878037im, 0.7512947997608432 + 0.3674310723252597im, 0.9988050552502091 + 0.0029096085789731907im, 0.7512947997608432 - 0.3674310723252597im, 0.9970749584795174 - 0.0012252438866903255im, 0.6208158918571303 + 0.12562989857539014im, 0.9970749584795174 + 0.0012252438866903255im, 0.6208158918571303 - 0.12562989857539014im],
    k::Float64 = 0.0019551556590637824,
)
    for pole in p
        if(abs(pole) > 1)
            return -1.0
        end
    end
    for pole in p
        if(abs(pole) <= 1)
            return 1.0
        end
    end
end

# -1.0
rozwiazanie30()

# stabilność
function rozwiazanie31(;
    z::Vector{ComplexF64} = ComplexF64[0.9770662345700633 + 0.2129356082553556im, 0.9770662345700633 - 0.2129356082553556im, 0.9953653495144525 + 0.09616559148662007im, 0.9953653495144525 - 0.09616559148662007im],
    p::Vector{ComplexF64} = ComplexF64[0.8992055821204713 + 0.37055050212774043im, 0.8992055821204713 - 0.37055050212774043im, 2.3126784767056856 + 1.9108946238299669im, 0.5631173337373035 - 0.4652864185240649im],
    k::Float64 = 0.4468062264882645,
)
    for pole in p
        if(abs(pole) > 1)
            return -1.0
        end
    end
    for pole in p
        if(abs(pole) <= 1)
            return 1.0
        end
    end
end

# -1.0
rozwiazanie31()

# energia sygnału          
function rozwiazanie32(;
    b::Vector{Float64} = [0.4511188970715776, -3.388327368016588, 13.310682782530323, -34.640700686891236, 65.7997388406566, -95.30112448183237, 107.61634935027121, -95.30112448183237, 65.7997388406566, -34.640700686891236, 13.310682782530323, -3.388327368016588, 0.4511188970715779],
    a::Vector{Float64} = [1.0, -6.524563167178484, 22.224121022104814, -50.2391469781693, 83.06408460944284, -104.9794605035899, 103.69625038102731, -80.52622256937818, 48.86685568864445, -22.66163734588475, 7.684610429007473, -1.7292745092796833, 0.20350826056124854],
    x::Vector{Float64} = [-0.16, -0.22, 0.57, 0.0, -0.45, 0.03, -0.36, 0.68, 0.84, 0.33, -0.6, -0.18, 0.31, -0.41, 0.34, 0.8, -0.59, -0.31, -0.03, 0.55, -0.75, -0.39, -0.73, 0.38, -0.98, 0.62],
    L::Int = 60,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1) <= N)
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && (n - k + 1) <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end
    energy = sum(abs.(y) .^ 2)
    return energy
end

# 5.836300856501196
rozwiazanie32()

# wartość skuteczna          
function rozwiazanie33(;
    x::Vector{Float64} = [-3.4, 4.55, 2.32, 3.23, -4.0, 0.94, -0.29, 2.36, -0.45, -1.34, 0.75, 1.04, 1.76, 2.83, 3.87, -3.94, 0.09, -3.66, 0.9, 3.65, 0.61, -2.43, 2.02, 3.21, -4.41, -3.9, -1.31, -1.9, 3.31, 3.93, -2.07, -2.11, 4.98, -3.98, 3.57, -0.93, 2.92, 4.36, -3.11, 0.28, -0.44, -2.26, -4.53, -3.52, -0.95, 4.52, 0.65, -3.71, 4.57, -1.89, 4.55, 1.01, -2.98, 3.84, 3.38, 3.55, 2.3, 2.33, -4.7, 3.3, 0.46, 0.35],
    h::Vector{Float64} = [-2.41, -4.21, 2.25, -0.19, -4.01, -2.57, -1.4, -4.64, 1.89, 0.12, 2.32, -3.56, -3.53, 1.7, 2.37, 4.31, -0.17],
)
    function conv(x, h)
        N = length(x)
        M = length(h)
        K = N + M - 1
        y = zeros(Float64, K)

        for n in 1:K
            for m in 1:M
                if((n - m) > 0 && (n - m + 1) <= N)
                    y[n] += h[m] * x[n - m + 1]
                end
            end
        end
        return y
    end

    y = conv(x, h)
    rms = sqrt(sum(abs.(y) .^ 2) / length(y))
    return rms
end

# 29.395120060147953
rozwiazanie33()

# suma faz
function rozwiazanie34(;
    fp::Int = 735,
    x::Vector{ComplexF64} = ComplexF64[-0.44 + 0.28im, 0.39 - 0.25im, 0.51 - 0.07im, 0.22 + 0.4im, 0.31 + 0.17im, -1.17 - 0.12im, -0.4 + 0.56im, -0.49 - 1.12im, -0.45 - 0.35im, -1.91 - 0.24im, -1.27 - 0.45im, -0.66 - 0.24im, 0.39 + 0.38im, -0.33 + 0.07im, 0.87 + 0.45im, 0.57 - 0.15im, 0.52 - 0.6im, -0.64 - 2.01im, -0.11 - 0.05im, 0.24 - 0.56im, -0.08 - 0.29im, 0.93 - 0.61im, 0.11 - 0.15im, -0.04 + 0.61im, 0.77 - 0.9im, -0.34 + 0.75im, -0.06 + 0.08im, 0.8 - 0.35im, -0.02 - 0.04im, 1.34 - 0.07im, 2.06 + 0.41im, -0.83 + 0.36im, 0.02 - 0.6im, 0.34 - 0.98im, -0.01 + 0.5im],
    f::Vector{Int} = [-357, -147, -126, 21, 63, 357],
)
    function dft(x)
        N = length(x)
        X = zeros(ComplexF64, N)

        for k in 1:N
            for n in 1:N
                X[k] += x[n] * cispi((-2 * (n - 1) * (k - 1)) / N)
            end
        end
        return X / N
    end

    N = length(x)
    Δf = fp / N
    X = dft(x)
    F = zeros(Float64, N)
    F[Int(floor(N / 2) + 2)] = -(floor((N - 1) / 2)) * Δf

    for i in 1:(N - 1)
        if((i + 1) != floor(N / 2) + 2)
            F[i + 1] += F[i] + Δf
        end
    end
    out = 0
    for i in 1:N
        if F[i] in f
            out += angle(X[i])
        end
    end
    return out
end

# 5.398019213756828
rozwiazanie34()

# średnie przesunięcie fazowe          
function rozwiazanie35(;
    b::Vector{Float64} = [0.00019557247105740462, 0.0, -0.000977862355287023, 0.0, 0.001955724710574046, 0.0, -0.001955724710574046, 0.0, 0.000977862355287023, 0.0, -0.00019557247105740462],
    a::Vector{Float64} = [1.0, -4.0246749393809615, 10.188689527777708, -17.257607928774696, 22.36506323141064, -22.013968411824003, 17.144425419018592, -10.134994974370263, 4.5824628653961845, -1.383565736318458, 0.2636472042716273],
    F::Vector{Float64} = [0.06, 0.18, 0.26],
)
    out = zeros(ComplexF64, length(F))
    for n in 1:length(F)
        num = 0
        denom = 0
        for m in 1:length(b)
            num += b[m] * exp(2im * π * F[n]) ^ -(m - 1)
        end
        for k in 2:length(a)
            denom += a[k] * exp(2im * π * F[n]) ^ -(k - 1)
        end
        out[n] += angle((num / (1 + denom)))
    end
    mean = sum(out) / length(out)
    return mean
end

# 0.03653033355660632
rozwiazanie35()

# wartość skuteczna sygnału          
function rozwiazanie36(;
    x::Vector{Float64} = [-1.64, 2.24, 3.04, 3.2, 2.54, 4.32, -3.72, -3.31, 2.33, -2.82, -4.22, 2.85, 0.12, -0.39, -3.52, -1.6, 1.65, -1.82, 0.44, -2.37, -4.3, -1.17, -4.28, 3.13, 1.12, -0.91, -4.81, 3.87, 1.97, 4.89, -3.93, -4.74, 4.0, -4.66, -0.65, 0.31, 3.08, -2.1, -4.97, -2.8, 4.48, 0.55, -0.54, -1.77, -3.7, 1.75, -0.99, -1.96, 4.15, -4.2, -0.88, -3.55, 4.11, 0.34, 3.79, 1.46, -1.15, 0.49, -1.03, 3.65, -4.24],
    h::Vector{Float64} = [3.89, -3.63, 2.46, 3.79, -2.23, -2.12, -2.49, -2.65, 0.29, 0.05],
)
    function conv(x, h)
        N = length(x)
        M = length(h)
        K = N + M - 1
        y = zeros(Float64, K)

        for n in 1:K
            for m in 1:M
                if((n - m) > 0 && (n - m + 1) <= N)
                    y[n] += h[m] * x[n - m + 1]
                end
            end
        end
        return y
    end

    y = conv(x, h)
    rms = sqrt(sum(abs.(y) .^ 2) / length(y))
    return rms
end

# 22.66915864568927
rozwiazanie36()

# stabilność          
function rozwiazanie37(;
    z::Vector{ComplexF64} = ComplexF64[0.8387442560635328 + 0.5445255484551953im, 0.8387442560635328 - 0.5445255484551953im, 0.8387442560635328 + 0.5445255484551953im, 0.8387442560635328 - 0.5445255484551953im, 0.8387442560635328 + 0.5445255484551953im, 0.8387442560635328 - 0.5445255484551953im, 0.8387442560635328 + 0.5445255484551953im, 0.8387442560635328 - 0.5445255484551953im],
    p::Vector{ComplexF64} = ComplexF64[0.5664259211467138 - 0.6662213733960115im, 0.8765545201484194 + 0.33607830353155554im, 0.5664259211467138 + 0.6662213733960115im, 0.8765545201484194 - 0.33607830353155554im, 0.5897432935477998 - 0.4455471268361333im, 0.7400204110228318 + 0.334420414936852im, 0.5897432935477998 + 0.4455471268361333im, 0.7400204110228318 - 0.334420414936852im],
    k::Float64 = 0.49273411376374726,
)
    for pole in p
        if(abs(pole) > 1)
            return -1.0
        end
    end
    for pole in p
        if(abs(pole) <= 1)
            return 1.0
        end
    end
end

# 1.0
rozwiazanie37()

# moc sygnału błędu kwantyzacji          
function rozwiazanie38(;
    a::Float64 = -6.3,
    b::Float64 = 2.8,
    x::Vector{Float64} = [0.876, 0.05036, -0.77528, -1.60092, -2.42656, -3.25221, -4.07785, -4.90349, -5.72913, -6.04523, -5.21959, -4.39395, -3.56831, -2.74267, -1.91703, -1.09138, -0.26574, 0.5599, 1.38554, 2.21118, 2.76318, 1.93754, 1.1119, 0.28626, -0.53938, -1.36503, -2.19067, -3.01631, -3.84195, -4.66759, -5.49323, -6.28113, -5.45549, -4.62985, -3.80421, -2.97856, -2.15292, -1.32728, -0.50164, 0.324, 1.14964, 1.97528, 2.80092, 2.17344, 1.34779, 0.52215, -0.30349, -1.12913, -1.95477, -2.78041, -3.60605, -4.43169, -5.25733, -6.08297],
)
    quantize(L) = x -> L[argmin(abs.(x .- L))]
    N = 9
    L = range(start = a, stop = b, length = 2 ^ N)
    
    q = quantize(L)
    x_q = q.(x)
    e = x - x_q
    power = sum(abs.(e) .^ 2) / length(e)
    return power
end

# 2.584056724908429e-5
rozwiazanie38()

# stabilność          
function rozwiazanie39(;
    z::Vector{ComplexF64} = ComplexF64[-0.0833585549577866 - 0.9965196191321823im, -0.0833585549577866 + 0.9965196191321823im, -1.0 + 0.0im],
    p::Vector{ComplexF64} = ComplexF64[0.6352186900832607 - 0.6381066908141123im, 0.6352186900832607 + 0.6381066908141123im, 0.7477997532117299 + 0.0im],
    k::Float64 = 0.031441589940550616,
)
    for pole in p
        if(abs(pole) > 1)
            return -1.0
        end
    end
    for pole in p
        if(abs(pole) <= 1)
            return 1.0
        end
    end
end

# 1.0
rozwiazanie39()

# suma wartości sygnału g(t)          
function rozwiazanie40(;
    m::Vector{Float64} = [1.8, 1.8013, 1.8026, 1.8039, 1.8052, 1.8065, 1.8078, 1.8091, 1.8104, 1.8117, 1.813, 1.8143, 1.8156, 1.8169, 1.8182, 1.8195, 1.8208, 1.8221, 1.8234, 1.8247, 1.826, 1.8273, 1.8286, 1.8299, 1.8312, 1.8325, 1.8338, 1.8351, 1.8364, 1.8377, 1.839, 1.8403, 1.8416, 1.8429, 1.8442, 1.8455, 1.8468, 1.8481, 1.8494, 1.8507, 1.852, 1.8533, 1.8546, 1.8559, 1.8572, 1.8585, 1.8598, 1.8611, 1.8624, 1.8637, 1.865, 1.8663, 1.8676, 1.8689, 1.8702, 1.8715],
    s::Vector{Float64} = [0.4889, 0.3072, 0.7329, 0.9983, 0.2644, 0.7341, 0.1348, 0.4822, 0.7266, 0.1376, 0.2883, 0.0497, 0.1478, 0.9672, 0.4463, 0.3089, 0.6525, 0.62, 0.7356, 0.4813, 0.693, 0.629, 0.3192, 0.5985, 0.6997, 0.377, 0.2533, 0.3364, 0.218, 0.2845, 0.5252, 0.1054, 0.759, 0.4357, 0.4395, 0.507, 0.0393, 0.5135, 0.8435, 0.704, 0.4048, 0.3117, 0.814, 0.4119, 0.5735, 0.0207, 0.4993, 0.0404, 0.6961, 0.8828, 0.4666, 0.0956, 0.2519, 0.7984, 0.0144, 0.118],
    t::Vector{Float64} = [1.8585, 1.84732, 1.85343, 1.82873, 1.86071, 1.81482, 1.85343, 1.86539, 1.82808],
)
    T = m[2] - m[1]
    out = zeros(Float64, length(t))

    for i in 1:length(t)
        for n in 1:length(s)
            out[i] += sinc((t[i] - m[n]) / T) * s[n]
        end
    end
    return sum(out)
end

# 2.2390848136478696
rozwiazanie40()

# średnie wzmocnienie  
# ???        
function rozwiazanie(;
    zz::Vector{ComplexF64} = ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im, -1.0 + 0.0im],
    pp::Vector{ComplexF64} = ComplexF64[0.6629285469528505 - 0.7100526844798914im, 0.2435636816050776 + 0.9310154893083475im, 0.6629285469528505 + 0.7100526844798914im, 0.2435636816050776 - 0.9310154893083475im, 0.5394023013757923 - 0.7484372268300734im, 0.36776103583483344 + 0.8357594754616966im, 0.5394023013757923 + 0.7484372268300734im, 0.36776103583483344 - 0.8357594754616966im],
    k::Float64 = 0.0007883274129675113,
    F::Vector{Float64} = [0.14, 0.23, 0.27, 0.28, 0.3, 0.45],
)
    out = zeros(ComplexF64, length(F))
    for n in 1:length(F)
        num = 0
        denom = 0
        for z in 1:length(zz)
            num += (zz[z] * exp(2im * π * F[n]) ^ -(z - 1))
        end
        for p in 2:length(pp)
            denom += (pp[p] * exp(2im / π * F[n]) ^ -(p - 1))
        end
        out[n] = (k * num) / (1 + denom)
    end
    mean = sum(abs.(out)) / length(out)
    return mean
end

rozwiazanie()

# stabilność
function rozwiazanie42(;
    z::Vector{ComplexF64} = ComplexF64[0.9241139879994743 - 0.38211691559483146im, 0.8554968213285832 + 0.5178080616374088im, 0.9241139879994743 + 0.38211691559483146im, 0.8554968213285832 - 0.5178080616374088im, 0.9167328078028022 - 0.3995008874808547im, 0.867932216871128 + 0.4966826621870037im, 0.9167328078028022 + 0.3995008874808547im, 0.867932216871128 - 0.4966826621870037im, 0.8949784703191255 + 0.44610933375713885im, 0.8949784703191255 - 0.44610933375713885im],
    p::Vector{ComplexF64} = ComplexF64[1.6866761338036136 + 1.074766774541014im, 0.927971549517992 - 0.3660388151962868im, 0.8403197850116767 - 0.5354601080904102im, 0.927971549517992 + 0.3660388151962868im, 0.7983410764186363 + 0.5520890265497784im, 0.9223954923317764 - 0.3373925628725653im, 0.7983410764186363 - 0.5520890265497784im, 0.9223954923317764 + 0.3373925628725653im, 0.6381637329064328 - 0.1372791431397875im, 0.6381637329064328 + 0.1372791431397875im],
    k::Float64 = 0.6649153547088238,
)
    for pole in p
        if(abs(pole) > 1)
            return -1.0
        end
    end
    for pole in p
        if(abs(pole) <= 1)
            return 1.0
        end
    end
end

# -1.0
rozwiazanie42()

# suma wartości sygnału g(t)
function rozwiazanie43(;
    m::Vector{Float64} = [-1.1, -1.0985, -1.097, -1.0955, -1.094, -1.0925, -1.091, -1.0895, -1.088, -1.0865, -1.085, -1.0835, -1.082, -1.0805, -1.079, -1.0775, -1.076, -1.0745, -1.073, -1.0715, -1.07, -1.0685, -1.067, -1.0655, -1.064, -1.0625, -1.061, -1.0595, -1.058, -1.0565, -1.055, -1.0535, -1.052, -1.0505, -1.049, -1.0475, -1.046, -1.0445, -1.043, -1.0415, -1.04, -1.0385, -1.037, -1.0355, -1.034, -1.0325, -1.031, -1.0295, -1.028, -1.0265, -1.025, -1.0235, -1.022, -1.0205, -1.019, -1.0175, -1.016, -1.0145, -1.013, -1.0115, -1.01, -1.0085, -1.007, -1.0055, -1.004, -1.0025, -1.001, -0.9995, -0.998, -0.9965, -0.995, -0.9935, -0.992, -0.9905, -0.989],
    s::Vector{Float64} = [0.6217, 0.6193, 0.866, 0.2374, 0.5205, 0.0448, 0.8866, 0.6376, 0.6255, 0.8957, 0.4814, 0.7172, 0.7578, 0.7197, 0.8995, 0.3004, 0.6068, 0.5837, 0.604, 0.1856, 0.5236, 0.5007, 0.7393, 0.4508, 0.3199, 0.3779, 0.5803, 0.7665, 0.9419, 0.4002, 0.3861, 0.3575, 0.878, 0.1609, 0.1382, 0.6018, 0.3434, 0.5384, 0.9399, 0.8688, 0.7385, 0.5799, 0.8638, 0.4955, 0.0486, 0.7087, 0.6399, 0.7978, 0.7732, 0.7555, 0.4127, 0.9256, 0.4294, 0.8702, 0.2426, 0.6888, 0.9693, 0.8222, 0.6128, 0.675, 0.4966, 0.7472, 0.2582, 0.0447, 0.3547, 0.0297, 0.7105, 0.0495, 0.4925, 0.5506, 0.2223, 0.3726, 0.9595, 0.7622, 0.6863],
    t::Vector{Float64} = [-1.082, -1.0544, -1.0928, -1.0484],
)
    T = m[2] - m[1]
    out = zeros(Float64, length(t))

    for i in 1:length(t)
        for n in 1:length(s)
            out[i] += sinc((t[i] - m[n]) / T) * s[n]
        end
    end
    return sum(out)
end

# 1.7112738862932044
rozwiazanie43()

# średnia dyskretnego sygnału
# fala piłokształtna o narastającym zboczu: A = 1, T = 1s, składowa stała: 0, g(0) = 0, dg/dt|t=0 = 2
function rozwiazanie44(;
    fp::Float64 = 179.31,
    t1::Float64 = -2.95,
    N::Int = 26,
)
    g(t) = 2 * (t - floor(t + 0.5))
    x = range(start = t1, step = 1 / fp, length = N)
    y = [1.6 * g(0.3 * t - 3.5) for t in x]
    mean = sum(y) / length(y)
    return mean
end

# -1.165076794378451
rozwiazanie44()

# energia sygnału
function rozwiazanie45(;
    x::Vector{Float64} = [2.89, -2.01, 1.42, 3.24, 3.05, -2.63, 2.88, 0.35, 0.99, -0.87, -0.83, 4.14, -3.45, -1.57, -3.58, -2.37, -2.19, -4.31, -4.64, 4.88, 0.12, -1.53, -2.76, 2.91, 0.57, 1.38, -0.85, -4.75, 1.01, -1.97, 4.85, -1.33, 0.32, 3.04, -4.91, -2.57, -3.8, 2.79, -2.76, 4.35, 0.11, 3.7, -4.47, -4.17, -2.34, -2.89, -2.3, 1.14, 4.63, -2.67, 3.24, 2.48, -0.36, 2.75, 1.1, -1.86, -0.02, -4.55, 4.84, 3.46, 2.96, 3.02],
    h::Vector{Float64} = [-3.22, 2.85, 4.8, -1.03, -3.56, 1.72, 0.52, -1.6, 1.97, 3.73, -1.43, 2.86, 0.51, -2.56, -1.39],
)
    function conv(x, h)
        N = length(x)
        M = length(h)
        K = N + M - 1
        y = zeros(Float64, K)

        for n in 1:K
            for m in 1:M
                if((n - m) > 0 && (n - m + 1) <= N)
                    y[n] += h[m] * x[n - m + 1]
                end
            end
        end
        return y
    end

    y = conv(x, h)
    energy = sum(abs.(y) .^ 2)
    return energy 
end

# 42222.55952057001
rozwiazanie45()

# stabilność
function rozwiazanie46(;
    z::Vector{ComplexF64} = ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im],
    p::Vector{ComplexF64} = ComplexF64[0.415879470880599 - 0.8235448265333332im, 0.415879470880599 + 0.8235448265333332im, 0.049248857019034135 - 0.686870715924473im, 0.049248857019034135 + 0.686870715924473im, -0.35831713448925134 + 0.0im],
    k::Float64 = 0.0846119006068186,
)
    for pole in p
        if(abs(pole) > 1)
            return -1.0
        end
    end
    for pole in p
        if(abs(pole) <= 1)
            return 1.0
        end
    end
end

# 1.0
rozwiazanie46()

# stabilność          
function rozwiazanie47(;
    z::Vector{ComplexF64} = ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im],
    p::Vector{ComplexF64} = ComplexF64[0.7460093798411808 - 0.3040142062246663im, 3.7042228885384088 + 1.5095472142427888im, 0.6346192975441481 - 0.0im],
    k::Float64 = 0.6417869649707927,
)
    for pole in p
        if(abs(pole) > 1)
            return -1.0
        end
    end
    for pole in p
        if(abs(pole) <= 1)
            return 1.0
        end
    end
end

# -1.0
rozwiazanie47()

# średnie przesunięcie fazowe     
function rozwiazanie48(;
    b::Vector{Float64} = [0.0042036847822194195, 0.0210184239110971, 0.0420368478221942, 0.0420368478221942, 0.0210184239110971, 0.0042036847822194195],
    a::Vector{Float64} = [1.0, -2.706368477287315, 3.842079062472673, -3.203777928793533, 1.5618466716574666, -0.35926141501827],
    F::Vector{Float64} = [0.09, 0.19, 0.41, 0.44, 0.49],
)
    out = zeros(ComplexF64, length(F))
    for i in 1:length(F)
        num = 0
        denom = 0
        for n in 1:length(b)
            num += (b[n] * exp(2im * π * F[i]) ^ -(n - 1))
        end
        for m in 2:length(a)
            denom += (a[m] * exp(2im * π * F[i]) ^ -(m - 1))
        end
        out[i] += angle(num / (1 + denom))
    end
    mean = sum(out) / length(out)
    return mean
end

# -1.285516946901584
rozwiazanie48()

# stabilność          
function rozwiazanie49(;
    z::Vector{ComplexF64} = ComplexF64[1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im, 1.0 + 0.0im],
    p::Vector{ComplexF64} = ComplexF64[0.27151631660871545 - 0.6335706544716929im, 0.27151631660871545 + 0.6335706544716929im, 0.19802273402750395 - 0.1913984811887362im, 0.19802273402750395 + 0.1913984811887362im],
    k::Float64 = 0.18565758606340266,
)
    for pole in p
        if(abs(pole) > 1)
            return -1.0
        end
    end
    for pole in p
        if(abs(pole) <= 1)
            return 1.0
        end
    end
end

# 1.0
rozwiazanie49()

# średnie przesunięcie fazowe          
function rozwiazanie50(;
    b::Vector{Float64} = [0.32371432562211677, -0.9711429768663503, 0.9711429768663503, -0.32371432562211677],
    a::Vector{Float64} = [1.0, -0.926717845968933, 0.5626891635060279, -0.10030759550197381],
    F::Vector{Float64} = [0.1, 0.17, 0.23, 0.31],
)
    out = zeros(ComplexF64, length(F))
    for n in 1:length(F)
        num = 0
        denom = 0
        for m in 1:length(b)
            num += b[m] * exp(2im * π * F[n]) ^ -(m - 1)
        end
        for k in 2:length(a)
            denom += a[k] * exp(2im * π * F[n]) ^ -(k - 1)
        end
        out[n] += angle((num / (1 + denom)))
    end
    mean = sum(out) / length(out)
    return mean
end

# 0.4800765929552881
rozwiazanie50()

# moc sygnału błędu kwantyzacji
function rozwiazanie51(;
    a::Float64 = 0.012,
    b::Float64 = 1.0,
    x::Vector{Float64} = [0.07477, 0.7299, 0.80496, 0.88028, 0.49394, 0.89877, 0.60744, 0.18665, 0.56598, 0.19585, 0.85945, 0.55295, 0.22819, 0.25808, 0.37394, 0.99842, 0.30279, 0.47097, 0.75707, 0.27037, 0.04782, 0.52669, 0.55857, 0.12646, 0.44636, 0.86062, 0.88564, 0.43732, 0.28452, 0.9363, 0.7269, 0.4722, 0.29591, 0.93226, 0.84208, 0.03063, 0.11893, 0.06907, 0.66832, 0.37145, 0.15553, 0.72058, 0.56018, 0.84554, 0.83837, 0.96242, 0.7936, 0.12484, 0.45566, 0.48648, 0.44973, 0.31792, 0.78615, 0.34063, 0.25898, 0.84529, 0.5533, 0.72595, 0.19386, 0.27143, 0.69866, 0.6123, 0.56775, 0.17169, 0.14546, 0.75383, 0.09231, 0.07095, 0.39753, 0.42692, 0.73835, 0.21387, 0.25728, 0.86432, 0.227, 0.55709, 0.70122, 0.12822, 0.20047, 0.19635, 0.4604, 0.82069, 0.81102, 0.97281, 0.01204, 0.13361, 0.42198, 0.75705, 0.67349, 0.8526, 0.81195, 0.17007, 0.10092, 0.64686, 0.56823, 0.06534, 0.15577, 0.38352],
)
    quantize(L) = x -> L[argmin(abs.(x .- L))]
    N = 6
    L = range(start = a, stop = b, length = 2 ^ N)

    q = quantize(L)
    x_q = q.(x)
    e = x - x_q
    power = sum(abs.(e) .^ 2) / length(e)
    return power
end

# 2.1909275040235263e-5
rozwiazanie51()

# energia sygnału          
function rozwiazanie52(;
    x::Vector{Float64} = [-1.16, -3.3, 4.17, 4.07, 2.06, 0.63, -2.22, -3.4, 3.18, 4.85, -0.87, -3.42, 4.92, 2.54, 0.02, 2.04, 2.85, -1.4, -4.8, 1.75, -4.58, 2.96, 1.6, 0.54, 1.58, -1.04, -1.55, -3.16, -1.03, -4.09, -3.31, 3.69, 3.33, -2.47, -3.88, 4.85, -3.17, -4.04, 4.05, 0.48, -5.0, -1.19, 4.95, 3.77, -4.2, 4.68, 3.94, 3.9, 2.61, -1.44, -4.89, 3.76, 3.3, -1.18, 3.95, 2.09, -4.89, -1.51, -3.39, 3.06, 3.85, 2.74],
    h::Vector{Float64} = [4.41, 4.96, 3.28, -2.95, -1.9, 1.94, 4.79, 0.14, -4.96, 2.33, 3.57, 0.47, 0.11, -4.24, -5.0, -2.1],
)
    function conv(x, h)
        N = length(x)
        M = length(h)
        K = N + M - 1
        y = zeros(Float64, K)

        for n in 1:K
            for m in 1:M
                if((n - m) > 0 && (n - m + 1) <= N)
                    y[n] += h[m] * x[n - m + 1]
                end
            end
        end
        return y
    end

    y = conv(x, h)
    energy = sum(abs.(y) .^ 2)
    return energy
end

# 127947.32986077995
rozwiazanie52()

# energia sygnału          
function rozwiazanie53(;
    b::Vector{Float64} = [0.36075153839087815, -2.7748190284344565, 10.98131002874287, -28.68172786658321, 54.53783473826815, -79.0236617799787, 89.2326712457515, -79.02366177997872, 54.53783473826817, -28.681727866583227, 10.981310028742877, -2.774819028434458, 0.3607515383908782],
    a::Vector{Float64} = [1.0, -6.494976920501914, 21.652943484980515, -47.895762808503505, 77.65516261475807, -96.69202877665714, 94.66807793960093, -73.49918801911508, 45.09936247201687, -21.484863618531218, 7.642262790675172, -1.8548457936466547, 0.23981340668309592],
    x::Vector{Float64} = [0.12, 0.81, 0.75, 0.16, 0.94, 0.88, 0.94, 0.03, -0.94, -0.26, -0.95, 0.08, 0.8, -0.63, 0.23, -0.07, -0.18, -0.67, 0.0, -0.93, -0.38, -0.22, 0.88, 0.18, -0.23, -0.12],
    L::Int = 46,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1) <= N)
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && (n - k + 1) <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end
    energy = sum(abs.(y) .^ 2)
    return energy
end

# 5.793373912475136
rozwiazanie53()

# 9.06.2025
# średnia dyskretnego sygnału   
# fala piłokształtna o opadającym zboczu: A = 1, T = 1s, składowa stała: 0, g(0) = 0, dg/dt|t=0 = -2        
function rozwiazanie54(;
    fp::Float64 = 276.88,
    t1::Float64 = -2.91,
    N::Int = 430,
)
    g(t) = -2 * (t - floor(t + 0.5))
    x = range(start = t1, step = 1 / fp, length = N)
    y = [1.8 * g(0.4 * t - 2.0) for t in x]
    mean = sum(y) / length(y)
    return mean
end

# -0.5251735336607916
rozwiazanie54()

# wartość skuteczna sygnału
function rozwiazanie55(;
    b::Vector{Float64} = [0.3757899352158341, -1.9527551364270286, 5.285845756657121, -9.094927720306911, 10.852128285073531, -9.094927720306911, 5.28584575665712, -1.9527551364270275, 0.3757899352158339],
    a::Vector{Float64} = [1.0, -4.281959903460196, 9.568903988559057, -13.930574496897968, 14.43659413591283, -10.845331345268585, 5.887617239568579, -2.1526678868169586, 0.43046923518197955],
    x::Vector{Float64} = [-0.46, 0.52, 0.37, 0.28, -0.18, 0.64, 0.96, -0.58, -0.91, 0.49, 0.96, -0.24, 0.18, 0.28, 0.89, 0.7, 0.92, -0.85, 0.6, -0.94, 0.36, 0.48, -0.41, -0.87, -0.2, 0.32, 0.48, 0.12, 0.86, -0.42, -0.29, -0.52, -0.26, -0.39, -0.7, 0.61, -0.85, -0.84, 0.16, -0.88, 0.04, -0.59, -0.03, -0.42, -0.35, -0.11, -0.86, 0.44],
    L::Int = 91,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1) <= N)
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && (n - k + 1) <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end
    rms = sqrt(sum(abs.(y) .^ 2) / length(y))
    return rms 
end

# 0.327155285413564
rozwiazanie55()

# suma wartości sygnału
function rozwiazanie56(;
    m::Vector{Float64} = [0.8, 0.8016, 0.8032, 0.8048, 0.8064, 0.808, 0.8096, 0.8112, 0.8128, 0.8144, 0.816, 0.8176, 0.8192, 0.8208, 0.8224, 0.824, 0.8256, 0.8272, 0.8288, 0.8304, 0.832, 0.8336, 0.8352, 0.8368, 0.8384, 0.84, 0.8416, 0.8432, 0.8448, 0.8464, 0.848, 0.8496, 0.8512, 0.8528, 0.8544, 0.856, 0.8576, 0.8592, 0.8608, 0.8624, 0.864, 0.8656, 0.8672, 0.8688, 0.8704, 0.872, 0.8736, 0.8752, 0.8768, 0.8784, 0.88, 0.8816, 0.8832, 0.8848, 0.8864, 0.888, 0.8896, 0.8912, 0.8928, 0.8944, 0.896, 0.8976, 0.8992, 0.9008, 0.9024, 0.904, 0.9056, 0.9072, 0.9088, 0.9104, 0.912, 0.9136, 0.9152, 0.9168, 0.9184, 0.92, 0.9216, 0.9232, 0.9248, 0.9264, 0.928, 0.9296, 0.9312, 0.9328, 0.9344],
    s::Vector{Float64} = [0.2913, 0.8348, 0.0972, 0.4099, 0.7634, 0.8844, 0.8673, 0.0297, 0.1271, 0.6358, 0.3053, 0.5623, 0.3888, 0.7527, 0.2873, 0.2664, 0.8709, 0.2963, 0.0217, 0.6618, 0.6209, 0.3974, 0.997, 0.6558, 0.0454, 0.5492, 0.1556, 0.6246, 0.1051, 0.3063, 0.3933, 0.7425, 0.365, 0.9576, 0.9051, 0.2682, 0.4774, 0.2376, 0.8763, 0.081, 0.7996, 0.1143, 0.062, 0.0491, 0.5763, 0.4312, 0.7421, 0.7636, 0.7129, 0.6168, 0.957, 0.9631, 0.1656, 0.1918, 0.2718, 0.2564, 0.7213, 0.9104, 0.7651, 0.3669, 0.3178, 0.0868, 0.8382, 0.1881, 0.054, 0.6483, 0.6879, 0.9392, 0.3832, 0.568, 0.9263, 0.5509, 0.4575, 0.7112, 0.7409, 0.8527, 0.0744, 0.4531, 0.3276, 0.7981, 0.3058, 0.4807, 0.7942, 0.6723, 0.7428],
    t::Vector{Float64} = [0.92432, 0.91104, 0.82624],
)
    T = m[2] - m[1]
    out = zeros(Float64, length(t))
    for i in 1:length(t)
        for n in 1:length(s)
            out[i] += sinc((t[i] - m[n]) / T) * s[n]
        end
    end
    return sum(out)
end

# 1.866656561788532
rozwiazanie56()

# średnia dyskretnego sygnału  
# fala piłokształtna o opadającym zboczu: A = 1, T = 1s, składowa stała: 0, g(0) = 0, dg/dt|t=0 = -2        
function rozwiazanie57(;
    fp::Float64 = 183.23,
    t1::Float64 = 4.45,
    N::Int = 376,
)
    g(t) = -2 * (t - floor(t + 0.5))
    x = range(start = t1, step = 1 / fp, length = N)
    y = [1.3 * g(0.0 * t - 1.2) for t in x]
    mean = sum(y) / length(y)
    return mean
end

# 0.5199999999999999
rozwiazanie57()

# suma wartości sygnału g(t)
function rozwiazanie58(;
    m::Vector{Float64} = [-1.7, -1.6988, -1.6976, -1.6964, -1.6952, -1.694, -1.6928, -1.6916, -1.6904, -1.6892, -1.688, -1.6868, -1.6856, -1.6844, -1.6832, -1.682, -1.6808, -1.6796, -1.6784, -1.6772, -1.676, -1.6748, -1.6736, -1.6724, -1.6712, -1.67, -1.6688, -1.6676, -1.6664, -1.6652, -1.664, -1.6628, -1.6616, -1.6604, -1.6592, -1.658, -1.6568, -1.6556, -1.6544, -1.6532, -1.652, -1.6508, -1.6496, -1.6484, -1.6472, -1.646, -1.6448, -1.6436, -1.6424, -1.6412, -1.64, -1.6388, -1.6376, -1.6364, -1.6352, -1.634, -1.6328, -1.6316, -1.6304, -1.6292, -1.628, -1.6268, -1.6256, -1.6244, -1.6232, -1.622, -1.6208, -1.6196, -1.6184, -1.6172, -1.616, -1.6148, -1.6136, -1.6124, -1.6112, -1.61, -1.6088, -1.6076, -1.6064, -1.6052, -1.604, -1.6028, -1.6016, -1.6004, -1.5992, -1.598, -1.5968, -1.5956, -1.5944],
    s::Vector{Float64} = [0.073, 0.826, 0.4393, 0.3709, 0.0217, 0.7837, 0.8636, 0.7069, 0.8607, 0.901, 0.5935, 0.3609, 0.1733, 0.4864, 0.914, 0.937, 0.1924, 0.5162, 0.1661, 0.425, 0.9898, 0.6368, 0.2744, 0.9844, 0.7333, 0.107, 0.6602, 0.3233, 0.7572, 0.326, 0.6598, 0.327, 0.0094, 0.427, 0.7454, 0.4594, 0.7686, 0.0138, 0.6439, 0.1398, 0.0315, 0.9401, 0.5367, 0.4125, 0.539, 0.4291, 0.8833, 0.6811, 0.7871, 0.6005, 0.9095, 0.4855, 0.4834, 0.5371, 0.9438, 0.4783, 0.0841, 0.9699, 0.7491, 0.4536, 0.9575, 0.8722, 0.1739, 0.655, 0.8125, 0.4422, 0.2807, 0.2154, 0.3494, 0.8691, 0.0843, 0.5821, 0.6151, 0.443, 0.6799, 0.6563, 0.3777, 0.5771, 0.957, 0.0698, 0.0167, 0.834, 0.1857, 0.9735, 0.2864, 0.086, 0.5978, 0.9477, 0.9141],
    t::Vector{Float64} = [-1.61132, -1.66904, -1.655, -1.65032, -1.64156, -1.67528],
)
    T = m[2] - m[1]
    out = zeros(Float64, length(t))

    for i in 1:length(t)
        for n in 1:length(s)
            out[i] += sinc((t[i] - m[n]) / T) * s[n]
        end
    end
    return sum(out)
end

# 3.8499673670837105
rozwiazanie58()

# średnia sygnału  
# fala trójkątna: A = 1, T = 1s składowa stała: 0, g(0) = 0, dg/dt|t=0 = 4        
function rozwiazanie59(;
    fp::Float64 = 231.5,
    t1::Float64 = -6.61,
    N::Int = 784,
)
    g(t) = 4 * abs(t - floor(t + 3 / 4) + 1 / 4) - 1
    x = range(start = t1, step = 1 / fp, length = N)
    y = [3.4 * g(1.0 * t - 0.9) for t in x]
    mean = sum(y) / length(y)
    return mean
end

# -0.21903151584607924
rozwiazanie59()

# suma wartości sygnału          
function rozwiazanie60(;
    m::Vector{Float64} = [0.7, 0.7021, 0.7042, 0.7063, 0.7084, 0.7105, 0.7126, 0.7147, 0.7168, 0.7189, 0.721, 0.7231, 0.7252, 0.7273, 0.7294, 0.7315, 0.7336, 0.7357, 0.7378, 0.7399, 0.742, 0.7441, 0.7462, 0.7483, 0.7504, 0.7525, 0.7546, 0.7567, 0.7588, 0.7609, 0.763, 0.7651, 0.7672, 0.7693, 0.7714, 0.7735, 0.7756, 0.7777, 0.7798, 0.7819, 0.784, 0.7861, 0.7882, 0.7903, 0.7924, 0.7945, 0.7966, 0.7987, 0.8008, 0.8029, 0.805, 0.8071, 0.8092, 0.8113, 0.8134, 0.8155, 0.8176, 0.8197, 0.8218, 0.8239, 0.826, 0.8281],
    s::Vector{Float64} = [0.8062, 0.105, 0.9226, 0.6305, 0.2082, 0.1596, 0.5659, 0.5903, 0.573, 0.3868, 0.2649, 0.9611, 0.7684, 0.9426, 0.4997, 0.4724, 0.0502, 0.5189, 0.8116, 0.4018, 0.455, 0.1894, 0.4783, 0.2868, 0.1985, 0.4332, 0.222, 0.8237, 0.235, 0.4697, 0.6242, 0.0096, 0.9308, 0.2745, 0.4311, 0.3991, 0.334, 0.2779, 0.6074, 0.9586, 0.4197, 0.6963, 0.2613, 0.0456, 0.7467, 0.1359, 0.6622, 0.4538, 0.7331, 0.3658, 0.707, 0.5706, 0.4959, 0.4145, 0.6383, 0.1988, 0.12, 0.3813, 0.2726, 0.8318, 0.8072, 0.3202],
    t::Vector{Float64} = [0.77287, 0.77644, 0.81277, 0.80311, 0.71554, 0.76426, 0.82285, 0.78043],
)
    T = m[2] - m[1]
    out = zeros(Float64, length(t))
    for i in 1:length(t)
        for n in 1:length(s)
            out[i] += sinc((t[i] - m[n]) / T) * s[n]
        end
    end
    return sum(out)
end

# 3.554066443439556
rozwiazanie60()

# średnia dyskretnego sygnału 
# fala trójkątna: A = 1, T = 1s składowa stała: 0, g(0) = 0, dg/dt|t=0 = 4         
function rozwiazanie61(;
    fp::Float64 = 198.88,
    t1::Float64 = -5.79,
    N::Int = 444,
)
    g(t) = 4 * abs(t - floor(t + 0.75) + 0.25) - 1
    x = range(start = t1, step = 1 / fp, length = N)
    y = [4.1 * g(0.3 * t - 3.6) for t in x]
    mean = sum(y) / length(y)
    return mean
end

# -0.02327561914287611
rozwiazanie61()

# wartość skuteczna sygnału błędu kwantyzacji
function rozwiazanie62(;
    a::Float64 = -1.2,
    b::Float64 = 4.0,
    x::Vector{Float64} = [-0.428, -0.23608, -0.04416, 0.14777, 0.33969, 0.53161, 0.72353, 0.91546, 1.10738, 1.2993, 1.49122, 1.68315, 1.87507, 2.06699, 2.25891, 2.45084, 2.64276, 2.83468, 3.0266, 3.21853, 3.41045, 3.60237, 3.79429, 3.98622, -1.22186, -1.02994, -0.83802, -0.64609, -0.45417, -0.26225, -0.07033, 0.1216, 0.31352, 0.50544, 0.69736, 0.88929, 1.08121, 1.27313, 1.46505, 1.65698, 1.8489, 2.04082, 2.23274, 2.42467, 2.61659, 2.80851, 3.00043, 3.19236, 3.38428, 3.5762, 3.76812, 3.96005, -1.24803, -1.05611, -0.86419, -0.67226, -0.48034, -0.28842, -0.0965, 0.09542, 0.28735, 0.47927, 0.67119, 0.86311, 1.05504, 1.24696, 1.43888, 1.6308, 1.82273],
)
    quantize(L) = x -> L[argmin(abs.(x .- L))]
    N = 7
    L = range(start = a, stop = b, length = 2 ^ N)

    q = quantize(L)
    x_q = q.(x)
    e = x - x_q
    rms = sqrt(sum(abs.(e) .^ 2) / length(e))
    return rms
end

# 0.013141409899992627
rozwiazanie62()

# wartość skuteczna sygnału          
function rozwiazanie63(;
    b::Vector{Float64} = [0.023318930393055663, -0.03396641140150994, 0.003626949865061721, 2.588921343200175e-18, -0.0036269498650617236, 0.03396641140150994, -0.02331893039305566],
    a::Vector{Float64} = [1.0, -3.4600294765615622, 6.283490012929209, -7.016050071823377, 5.179160259053267, -2.3390096895578876, 0.5585961825878288],
    x::Vector{Float64} = [-0.08, 0.46, -0.88, -0.1, 0.5, -0.42, 0.07, 0.36, 0.81, 0.62, -0.72, 0.15, 0.3, 0.28, 0.29, 0.69, -0.59, -0.53, -0.77, 0.18, -0.46, -0.94, 0.86, 0.71, -0.85, 0.99, 0.12, -0.13, -0.67, -0.82, 0.7, -0.97, 0.64, -0.65, -0.27, 0.86, 0.85, -0.16, 0.66, 0.38, -0.83, 0.79, -0.13, -0.79, -0.07, 0.59, 0.15, -0.52],
    L::Int = 77,
)
    N = length(x)
    M = length(b)
    K = length(a)
    y = zeros(Float64, L)

    for n in 1:L
        for m in 1:M
            if((n - m + 1) > 0 && (n - m + 1) <= N)
                y[n] += b[m] * x[n - m + 1]
            end
        end
        for k in 2:K
            if((n - k + 1) > 0 && (n - k + 1) <= L)
                y[n] -= a[k] * y[n - k + 1]
            end
        end
    end
    rms = sqrt(sum(abs.(y) .^ 2) / length(y))
    return rms
end

# 0.15896922352317172
rozwiazanie63()